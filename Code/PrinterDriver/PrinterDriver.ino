char header[] = {0x00, 0x1B, 0x40, 0x1B, 0x52, 0x00, 0x1B, //init header for epson lx-810
                 0x74, 0x01, 0x1B, 0x36, 0x12, 0x1B, 0x50
                };

char kanaHeader[] = {0x1B, 0x2A, 0x00, 0x0A, 0x00}; //init header for kana | sets graphics to single density 10 columns

//Hiragana 8x8 sprite list in order
char hiragana[][8] = {
  { 0x04, 0x3F, 0x04, 0x3C, 0x56, 0x4D, 0x26, 0x00},//A   あ
  { 0x00, 0x01, 0x11, 0x21, 0x21, 0x25, 0x02, 0x00},//I   い
  { 0x3C, 0x00, 0x3C, 0x42, 0x40, 0x20, 0x18, 0x00},//U   う
  { 0x1C, 0x00, 0x3E, 0x10, 0x38, 0x24, 0x62, 0x00},//E   え
  { 0x24, 0x4F, 0x04, 0x3C, 0x46, 0x45, 0x22, 0x00},//O   お
  { 0x04, 0x24, 0x4F, 0x54, 0x52, 0x12, 0x09, 0x00},//KA  か
  { 0x08, 0x1F, 0x08, 0x3F, 0x1C, 0x02, 0x3C, 0x00},//KI  き
  { 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00},//KU  く
  { 0x00, 0x22, 0x79, 0x21, 0x21, 0x22, 0x10, 0x00},//KE  け
  { 0x00, 0x00, 0x3C, 0x00, 0x02, 0x02, 0x3C, 0x00},//KO  こ
  { 0x44, 0x24, 0x0F, 0x54, 0x52, 0x52, 0x09, 0x00},//GA  が
  { 0x44, 0x2F, 0x04, 0x1F, 0x0E, 0x01, 0x1E, 0x00},//GI  ぎ
  { 0x28, 0x44, 0x12, 0x21, 0x02, 0x04, 0x08, 0x00},//GU  ぐ
  { 0x40, 0x22, 0x11, 0x3D, 0x11, 0x12, 0x08, 0x00},//GE  げ
  { 0x20, 0x40, 0x16, 0x20, 0x01, 0x01, 0x0E, 0x00},//GO  ご
  { 0x10, 0x7E, 0x10, 0x3C, 0x02, 0x02, 0x1C, 0x00},//SA  さ
  { 0x00, 0x02, 0x02, 0x02, 0x42, 0x22, 0x1C, 0x00},//SHI し
  { 0x10, 0x7E, 0x18, 0x14, 0x18, 0x10, 0x0C, 0x00},//SU  す
  { 0x20, 0x72, 0x2F, 0x22, 0x1A, 0x02, 0x1C, 0x00},//SE  せ
  { 0x1E, 0x08, 0x04, 0x7F, 0x08, 0x04, 0x38, 0x00},//SO  そ
  { 0x24, 0x4F, 0x14, 0x2E, 0x01, 0x01, 0x0E, 0x00},//ZA  ざ
  { 0x20, 0x42, 0x12, 0x22, 0x02, 0x22, 0x1C, 0x00},//JI  じ
  { 0x44, 0x2F, 0x06, 0x05, 0x06, 0x04, 0x03, 0x00},//ZU  ず
  { 0x80, 0x50, 0x3A, 0x17, 0x1A, 0x02, 0x1C, 0x00},//ZE  ぜ
  { 0x4F, 0x24, 0x02, 0x7F, 0x08, 0x04, 0x38, 0x00},//ZO  ぞ
  { 0x02, 0x0F, 0x02, 0x72, 0x02, 0x09, 0x71, 0x00},//TA  た
  { 0x08, 0x7E, 0x08, 0x3C, 0x40, 0x40, 0x38, 0x00},//CHI ち
  { 0x00, 0x1C, 0x22, 0x41, 0x40, 0x20, 0x1C, 0x00},//TSU つ
  { 0x00, 0x3E, 0x08, 0x04, 0x04, 0x04, 0x38, 0x00},//TE  て
  { 0x04, 0x04, 0x08, 0x3C, 0x02, 0x02, 0x3C, 0x00},//TO  と
  { 0x42, 0x2F, 0x02, 0x72, 0x02, 0x09, 0x71, 0x00},//DA  だ
  { 0x44, 0x2F, 0x04, 0x1E, 0x20, 0x20, 0x1C, 0x00},//DJI ぢ
  { 0x40, 0x20, 0x1E, 0x21, 0x20, 0x20, 0x1C, 0x00},//DZU づ
  { 0x00, 0x3E, 0x48, 0x24, 0x04, 0x04, 0x38, 0x00},//DE  で
  { 0x44, 0x24, 0x08, 0x3C, 0x02, 0x02, 0x3C, 0x00},//DO  ど
  { 0x32, 0x02, 0x27, 0x22, 0x72, 0x29, 0x11, 0x00},//NA  な
  { 0x00, 0x02, 0x7A, 0x02, 0x0A, 0x72, 0x02, 0x00},//NI  に
  { 0x08, 0x09, 0x3E, 0x4B, 0x65, 0x55, 0x22, 0x00},//NU  ぬ
  { 0x04, 0x07, 0x34, 0x4C, 0x66, 0x54, 0x24, 0x00},//NE  ね
  { 0x00, 0x00, 0x3C, 0x4A, 0x49, 0x45, 0x22, 0x00},//NO  の
  { 0x00, 0x22, 0x7A, 0x22, 0x72, 0x2A, 0x12, 0x00},//HA  は
  { 0x00, 0x00, 0x13, 0x32, 0x51, 0x11, 0x0E, 0x00},//HI  ひ
  { 0x1C, 0x00, 0x08, 0x2A, 0x49, 0x10, 0x0C, 0x00},//FU  ふ
  { 0x00, 0x00, 0x04, 0x0A, 0x11, 0x20, 0x40, 0x00},//HE  へ
  { 0x7D, 0x11, 0x7D, 0x11, 0x39, 0x55, 0x09, 0x00},//HO  ほ
  { 0x80, 0x51, 0x1D, 0x11, 0x39, 0x15, 0x09, 0x00},//BA  ば
  { 0x40, 0x20, 0x03, 0x32, 0x51, 0x11, 0x0E, 0x00},//BI  び
  { 0x4C, 0x20, 0x08, 0x2A, 0x49, 0x10, 0x0C, 0x00},//BU  ぶ
  { 0x20, 0x40, 0x14, 0x2A, 0x11, 0x20, 0x40, 0x00},//BE  べ
  { 0x9D, 0x51, 0x1D, 0x11, 0x39, 0x55, 0x09, 0x00},//BO  ぼ
  { 0x40, 0xB1, 0x5D, 0x11, 0x39, 0x15, 0x09, 0x00},//PA  ぱ
  { 0x40, 0xA0, 0x43, 0x32, 0x51, 0x11, 0x0E, 0x00},//PI  ぴ
  { 0x4C, 0xA0, 0x48, 0x0A, 0x29, 0x48, 0x0C, 0x00},//PU  ぷ
  { 0x20, 0x50, 0x24, 0x0A, 0x11, 0x20, 0x40, 0x00},//PE  ぺ
  { 0x5D, 0xB1, 0x5D, 0x11, 0x39, 0x55, 0x09, 0x00},//PO  ぽ
  { 0x7E, 0x08, 0x3E, 0x08, 0x1C, 0x2A, 0x04, 0x00},//MA  ま
  { 0x00, 0x07, 0x24, 0x24, 0x7E, 0x25, 0x12, 0x00},//MI  み
  { 0x04, 0x0F, 0x64, 0x06, 0x05, 0x26, 0x3C, 0x00},//MU  む
  { 0x00, 0x09, 0x3D, 0x4A, 0x4B, 0x45, 0x2A, 0x00},//ME  め
  { 0x02, 0x0F, 0x02, 0x0F, 0x62, 0x42, 0x3C, 0x00},//MO  も
  { 0x00, 0x12, 0x3F, 0x42, 0x42, 0x34, 0x04, 0x00},//YA  や
  { 0x00, 0x11, 0x3D, 0x53, 0x51, 0x39, 0x11, 0x00},//YU  ゆ
  { 0x08, 0x08, 0x38, 0x08, 0x1C, 0x2A, 0x04, 0x00},//YO  よ
  { 0x1E, 0x00, 0x02, 0x3A, 0x46, 0x42, 0x30, 0x00},//RA  ら
  { 0x00, 0x20, 0x22, 0x22, 0x2A, 0x24, 0x10, 0x00},//RI  り
  { 0x1F, 0x08, 0x3C, 0x42, 0x49, 0x54, 0x38, 0x00},//RU  る
  { 0x04, 0x07, 0x04, 0x0C, 0x16, 0x55, 0x24, 0x00},//RE  れ
  { 0x3F, 0x10, 0x08, 0x3C, 0x42, 0x41, 0x30, 0x00},//RO  ろ
  { 0x04, 0x07, 0x04, 0x3C, 0x46, 0x45, 0x24, 0x00},//WA  わ
  { 0x04, 0x0F, 0x04, 0x6E, 0x11, 0x08, 0x70, 0x00},//WO  を
  { 0x08, 0x08, 0x04, 0x0C, 0x56, 0x52, 0x21, 0x00},//N   ん
  { 0x40, 0x80, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00},//VOICED MARK
  { 0x40, 0xA0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00},//SEMIVOICED MARK
  { 0x00, 0x00, 0x08, 0x08, 0x10, 0x30, 0x0C, 0x00},//ITERATION MARK
  { 0x20, 0x40, 0x14, 0x24, 0x08, 0x18, 0x06, 0x00},//VOICED ITERATION MARK
  { 0x00, 0x00, 0x00, 0x1C, 0x22, 0x20, 0x1C, 0x00},//SMALL TSU っ
  { 0x00, 0x00, 0x12, 0x1F, 0x22, 0x12, 0x04, 0x00},//SMALL YA  ゃ
  { 0x00, 0x00, 0x11, 0x3D, 0x53, 0x39, 0x11, 0x00},//SMALL YU  ゅ
  { 0x00, 0x08, 0x38, 0x08, 0x1C, 0x2A, 0x04, 0x00},//SMALL YO  ょ
};

//katakana 8x8 sprite list in order
char katakana[][10] = {{0x81, 0x82, 0x84, 0xB8, 0x80, 0xA0, 0xC0, 0x80, 0x00, 0x00}};

void setup() {
  // put your setup code here, to run once:
  Serial.begin(2400);
  pinMode(2, OUTPUT); //pins 2-9 are data pins
  pinMode(3, OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(5, OUTPUT);
  pinMode(6, OUTPUT);
  pinMode(7, OUTPUT);
  pinMode(8, OUTPUT);
  pinMode(9, OUTPUT);
  pinMode(10, OUTPUT); //pin 10 is strobe
  pinMode(11, INPUT); //pin 11 is Busy signal
  digitalWrite(10, HIGH);

  //send init header
  for (int i = 0; i < sizeof(header); i++)
  {
    for (int j = 0; j < 8; j++)
    {
      if (((header[i] >> j) & 1) == 1)
      {
        digitalWrite(j + 2, HIGH);
      }
      else
      {
        digitalWrite(j + 2, LOW);
      }
    }
    delayMicroseconds(10);
    digitalWrite(10, LOW);
    delayMicroseconds(10);
    digitalWrite(10, HIGH);
    while (digitalRead(11) == HIGH) {};
  }
  Serial.println("Ready...");
}

int kanaCount = 0;
int kana = 0;
char buf[4];
int index = 0;
unsigned long guard = NULL;
void serialEvent()
{
  char data = Serial.read();
  Serial.print(data);

  //handle cr/lf wierdness
  if (data == 0x0d) {
    Serial.println();
  };

  //mode switch similar to the hayes command set
  //send 3 pluses then a guard period of 1.5 seconds
  //is data a plus
  if (data == 0x2B && !guard) {
    kanaCount++;
  }
  //cancel on receipt of 4th plus
  if (data == 0x2B && guard) {
    guard = NULL;
    for (int i = 0; i < kanaCount + 1; i++) {
      sendData(0x2b);
    }
    kanaCount = 0;
  }
  //cancel on receipt of any other character
  if (data != 0x2B) {
    if (guard) {
      for (int i = 0; i < kanaCount; i++) {
        sendData(0x2b);
      }
    }
    kanaCount = 0;
    guard = NULL;
  };
  //check for 3 pluses
  if (kanaCount >= 3) {
    guard = millis();

  }

  //if data is a control code, space, number/symbol, or not kana and it isn't + a plus
  if ((kana == 0 || (data & ~0x1f) == 0 || data == 0x20 || (data >> 4) == 3) && (data != 0x2B)) {
    sendData(data);
  }

  //else parse kana
  else if (kana == 1) {
    buf[index] = data; //add character to buffer

    //check if character is a vowel or n
    if (buf[index] == 'a' || buf[index] == 'i' || buf[index] == 'u' || buf[index] == 'e' || buf[index] == 'o' || (buf[index] == 'n' && buf[index - 1] == 'n')) {
      switch (buf[0]) {
        case 'a':
          sendKana(0);
          break;
        case 'i':
          sendKana(1);
          break;
        case 'u':
          sendKana(2);
          break;
        case 'e':
          sendKana(3);
          break;
        case 'o':
          sendKana(4);
          break;
        case 'k':
          switch (buf[1]) {
            case 'a':
              sendKana(5);
              break;
            case 'i':
              sendKana(6);
              break;
            case 'u':
              sendKana(7);
              break;
            case 'e':
              sendKana(8);
              break;
            case 'o':
              sendKana(9);
              break;
          }
          break;
        case 'g':
          switch (buf[1]) {
            case 'a':
              sendKana(10);
              break;
            case 'i':
              sendKana(11);
              break;
            case 'u':
              sendKana(12);
              break;
            case 'e':
              sendKana(13);
              break;
            case 'o':
              sendKana(14);
              break;
          }
          break;
        case 's':
          switch (buf[1]) {
            case 'a':
              sendKana(15);
              break;
            case 'i':
              sendKana(16);
              break;
            case 'u':
              sendKana(17);
              break;
            case 'e':
              sendKana(18);
              break;
            case 'o':
              sendKana(19);
              break;
          }
          break;
          case 'z':
          switch (buf[1]) {
            case 'a':
              sendKana(20);
              break;
            case 'i':
              sendKana(21);
              break;
            case 'u':
              sendKana(22);
              break;
            case 'e':
              sendKana(23);
              break;
            case 'o':
              sendKana(24);
              break;
          }
          break;
      }

      //clear buffer after printing
      for (int i = 0; i < index + 1; i++) {
        buf[i] = 0;
      }
      index = 0;
    } else {
      index++;//increment length of buffer

      //if length >=4 assume no good text and send to printer as ascii
      if (index >= 4) {
        for (int i = 0; i < index; i++) {
          sendData(buf[i]);
          buf[i] = 0;
        }
        index = 0;
      }
    }

    //    for (int i = 0; i < 5; i++) {
    //      sendData(kanaHeader[i]);
    //    }
    //    for (int i = 0; i < 8; i++) {
    //      sendData(hiragana[0][i]);
    //    }
    //    for (int i = 0; i < 2; i++) {
    //      sendData(0x00);
    //    }
  }
}

//takes a byte as input and sends it as parallel output
void sendData(char data)
{
  for (int j = 0; j < 8; j++)
  {
    if (((data >> j) & 1) == 1)
    {
      digitalWrite(j + 2, HIGH);
    }
    else
    {
      digitalWrite(j + 2, LOW);
    }
  }
  delayMicroseconds(10);
  digitalWrite(10, LOW);
  delayMicroseconds(10);
  digitalWrite(10, HIGH);
  while (digitalRead(11) == HIGH) {};
}

//array version of sendData
void sendKana(int index)
{
  for (int i = 0; i < 5; i++) {
    sendData(kanaHeader[i]);
  }
  for (int i = 0; i < 8; i++) {
    char data = 0;
    for (int j = 0; j < 8; j++) {
      data |= ((hiragana[index][j] >> i) & 1) << (7 - j);
    }
    sendData(data);
  }
  for (int i = 0; i < 2; i++) {
    sendData(0x00);
  }
}

void loop() {
  //logic for the guard interval timing
  if (guard && millis() - guard > 1000) {
    kana = (kana == 1) ? 0 : 1;
    Serial.print("Kana set to ");
    Serial.println(kana);
    kanaCount = 0;
    guard = NULL;
  }
}
